<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konno - Walking Character</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #1a1a1a;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
            background: #0a0a0a;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 800;
        
        // Zoom controls
        let zoom = 1;
        const minZoom = 0.5;
        const maxZoom = 3;
        const zoomStep = 0.1;
        
        // Character object (Konno)
        const character = {
            // === CHARACTER POSITION ===
            x: 400,
            y: 600,
            groundY: 600,
            // ===========================
            
            width: 128,
            height: 128,
            speed: 0.3,         // ← Normal walking speed
            floatSpeed: 0.9,    // ← Speed while floating (Left/Right)
            
            // Horizontal Boost/Turbo Speeds (Still uses multipliers for left/right)
            boostMultiplier: 1,
            turboMultiplier: 5,
            
            direction: 'left',
            isMoving: false,
            
            // Jump properties
            isJumping: false,
            velocityY: 0,
            jumpPower: 10,
            gravity: 0.3,
            
            // Glowing properties
            isGlowing: false,
            
            // Flying properties
            isFloating: false,
            isFlyingUp: false,
            isFlyingDown: false,
            isLanding: false,
            
            // Boost properties
            isBoost: false,
            isTurbo: false,
            boostStartTime: 0,
            boostDuration: 1500,
            
            // === VERTICAL SPEED CONTROLS ===
            // Normal
            flyUpSpeed: 2.1,          // Normal Up Speed (W key)
            flyDownSpeed: 2.1,        // Normal Down Speed (S key)
            
            // Boost (Shift)
            flyUpSpeedBoost: 1.5,     // Up Speed while Boosting
            flyDownSpeedBoost: 1.5,   // Down Speed while Boosting
            
            // Turbo (Hold Shift 3 sec)
            flyUpSpeedTurbo: 3.0,    // Up Speed while Turbo
            flyDownSpeedTurbo: 3.0,  // Down Speed while Turbo
            
            flyTargetY: 200,
            
            walkFrameIndex: 0,
            walkFrameDelay: 0.3, 
            walkFrameCounter: 0,
            
            idleFrameIndex: 0,
            idleFrameDelay: 3,
            idleFrameCounter: 0,
            
            jumpFrameIndex: 0,
            jumpFrameDelay: 3,
            jumpFrameCounter: 0,
            
            glowingFrameIndex: 0,
            glowingFrameDelay: 2,
            glowingFrameCounter: 0,
            
            floatFrameIndex: 0,
            floatFrameDelay: 0.7,
            floatFrameCounter: 0,
            
            flyUpFrameIndex: 0,
            flyUpFrameDelay: 0.5,
            flyUpFrameCounter: 0,
            
            flyDownFrameIndex: 0,
            flyDownFrameDelay: 0.5,
            flyDownFrameCounter: 0,
            
            landFrameIndex: 0,
            landFrameDelay: 0.5,
            landFrameCounter: 0,
            
            boostFrameIndex: 0,
            boostFrameDelay: 0.3,
            boostFrameCounter: 0,
            
            turboFrameIndex: 0,
            turboFrameDelay: 0.3,
            turboFrameCounter: 0,
            
            walkFrames: [],  
            idleFrames: [],
            jumpFrames: [],
            glowingFrames: [],
            floatFrames: [],
            flyUpFrames: [],
            flyDownFrames: [],
            landFrames: [],
            boostFrames: [],
            turboFrames: []
        };
        
        // Background Object with Parallax
        const background = {
            frames: [],
            frameIndex: 0,
            frameDelay: 3,
            frameCounter: 0,
            x: 0,
            parallaxSpeed: 15
        };
        
        // ===== HELPER TO GENERATE FILE NAMES =====
        function generateImageArray(prefix, count, folder) {
            let arr = [];
            for (let i = 1; i <= count; i++) {
                let numStr = i.toString().padStart(3, '0');
                arr.push(`${folder}${prefix}_${numStr}.png`);
            }
            return arr;
        }
        
        // === CONFIGURATION: UPDATE THESE NUMBERS TO MATCH YOUR FILES ===
        const walkCount = 126;
        const idleCount = 126;
        const jumpCount = 50;
        const glowingCount = 50;
        const floatCount = 42;
        const flyUpCount = 30;
        const flyDownCount = 30;
        const landCount = 110;
        const boostCount = 96;
        const turboCount = 77;
        const bgCount = 122;
        // ===============================================================
        
        const walkRightSrcs = generateImageArray('walk_right', walkCount, 'walk/');
        const idleSrcs = generateImageArray('Idle', idleCount, 'idle/');
        const jumpSrcs = generateImageArray('jmp', jumpCount, 'jump/');
        const glowingSrcs = generateImageArray('glowing', glowingCount, 'glowing/');
        const floatSrcs = generateImageArray('float', floatCount, 'float/');
        const flyUpSrcs = generateImageArray('higher', flyUpCount, 'higher/');
        const flyDownSrcs = generateImageArray('fly_down', flyDownCount, 'fly_down/');
        const landSrcs = generateImageArray('land', landCount, 'land/');
        const boostSrcs = generateImageArray('boost_speed', boostCount, 'boost_speed/');
        const turboSrcs = generateImageArray('turbo', turboCount, 'turbo/');
        const bgSrcs = generateImageArray('bg', bgCount, 'background/');
        
        // Load all images
        function loadImages() {
            walkRightSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.walkFrames.push(img);
            });
            idleSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.idleFrames.push(img);
            });
            jumpSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.jumpFrames.push(img);
            });
            glowingSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.glowingFrames.push(img);
            });
            floatSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.floatFrames.push(img);
            });
            flyUpSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.flyUpFrames.push(img);
            });
            flyDownSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.flyDownFrames.push(img);
            });
            landSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.landFrames.push(img);
            });
            boostSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.boostFrames.push(img);
            });
            turboSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                character.turboFrames.push(img);
            });
            bgSrcs.forEach(src => {
                const img = new Image();
                img.src = src;
                background.frames.push(img);
            });
            
            character.walkFrameCount = character.walkFrames.length;
            character.idleFrameCount = character.idleFrames.length;
            character.jumpFrameCount = character.jumpFrames.length;
            character.glowingFrameCount = character.glowingFrames.length;
            character.floatFrameCount = character.floatFrames.length;
            character.flyUpFrameCount = character.flyUpFrames.length;
            character.flyDownFrameCount = character.flyDownFrames.length;
            character.landFrameCount = character.landFrames.length;
            character.boostFrameCount = character.boostFrames.length;
            character.turboFrameCount = character.turboFrames.length;
            background.frameCount = background.frames.length;
            console.log(`Attempting to load: ${walkCount} walk, ${idleCount} idle, ${jumpCount} jump, ${glowingCount} glowing, ${floatCount} float, ${flyUpCount} flyUp, ${flyDownCount} flyDown, ${landCount} land, ${boostCount} boost, ${turboCount} turbo, ${bgCount} background frames.`);
        }
        loadImages();
        
        // Keyboard input
        const keys = {};
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            // === SPACEBAR LOGIC: Jump -> Float -> Land -> (Cancel to Float) ===
            if (e.key === ' ') {
                if (!character.isGlowing) {
                    
                    // 1. If LANDING, Press Space to cancel landing and go back to FLOATING
                    if (character.isLanding) {
                        character.isLanding = false;
                        character.velocityY = 0; // Stop gravity
                        character.isFloating = true;
                        character.floatFrameIndex = 0;
                    }
                    // 2. Start Jump (if on ground, idle, or walking)
                    else if (!character.isJumping && !character.isFloating && !character.isFlyingUp && !character.isFlyingDown) {
                        character.isJumping = true;
                        character.velocityY = -character.jumpPower;
                        character.jumpFrameIndex = 0;
                    } 
                    // 3. Jump -> Float (If already jumping)
                    else if (character.isJumping) {
                        character.isJumping = false;
                        character.velocityY = 0; // Stop gravity
                        character.isFloating = true;
                        character.floatFrameIndex = 0;
                    } 
                    // 4. Float -> Land (If currently floating, flying up, or flying down)
                    else if (character.isFloating || character.isFlyingUp || character.isFlyingDown) {
                        character.isFloating = false;
                        character.isFlyingUp = false;
                        character.isFlyingDown = false;
                        character.isLanding = true;
                        character.landFrameIndex = 0;
                    }
                }
            }
            
            // Glowing with G key
            if (e.key.toLowerCase() === 'g' && !character.isGlowing && !character.isJumping && !character.isFloating && !character.isLanding) {
                character.isGlowing = true;
                character.glowingFrameIndex = 0;
            }
            
            // Fly Up animation with W key (only when floating)
            if (e.key.toLowerCase() === 'w' && character.isFloating && !character.isFlyingUp && !character.isFlyingDown) {
                character.isFlyingUp = true;
                character.isFloating = false;
                character.flyUpFrameIndex = 0;
            }
            
            // Fly Down animation with S key (only when floating)
            if (e.key.toLowerCase() === 's' && character.isFloating && !character.isFlyingDown && !character.isFlyingUp) {
                character.isFlyingDown = true;
                character.isFloating = false;
                character.flyDownFrameIndex = 0;
            }
            
            // Boost/Turbo mode with Shift
            if (e.key === 'Shift' && (character.isFloating || character.isFlyingUp || character.isFlyingDown) && !character.isBoost && !character.isTurbo && (keys['a'] || keys['d'])) {
                character.isBoost = true;
                character.boostStartTime = Date.now();
                character.boostFrameIndex = 0;
            }
            
            if (e.key === '+' || e.key === '=') zoom = Math.min(zoom + zoomStep, maxZoom);
            if (e.key === '-' || e.key === '_') zoom = Math.max(zoom - zoomStep, minZoom);
            if (e.key === '0') zoom = 1;
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            
            // === CHANGE HERE: Release Shift forces Landing ===
            if (e.key === 'Shift' && (character.isBoost || character.isTurbo)) {
                character.isBoost = false;
                character.isTurbo = false;
                character.isFloating = false;
                character.isFlyingUp = false;
                character.isFlyingDown = false;
                
                // Force landing state
                character.isLanding = true;
                character.landFrameIndex = 0;
                character.boostStartTime = 0;
            }
            
            // When W is released during fly up animation, return to floating
            if (e.key.toLowerCase() === 'w' && character.isFlyingUp) {
                character.isFlyingUp = false;
                character.isFloating = true;
                character.floatFrameIndex = 0;
            }
            
            // When S is released during fly_down animation, return to floating
            if (e.key.toLowerCase() === 's' && character.isFlyingDown) {
                character.isFlyingDown = false;
                character.isFloating = true;
                character.floatFrameIndex = 0;
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) zoom = Math.min(zoom + zoomStep, maxZoom);
            else zoom = Math.max(zoom - zoomStep, minZoom);
        });
        
        // Update function
        function update() {
            // Check if boost should transition to turbo
            if (character.isBoost && !character.isTurbo && (keys['shift']) && (keys['a'] || keys['d'])) {
                const elapsedTime = Date.now() - character.boostStartTime;
                if (elapsedTime >= character.boostDuration) {
                    character.isBoost = false;
                    character.isTurbo = true;
                    character.turboFrameIndex = 0;
                }
            }
            
            // === SPEED LOGIC ===
            // Determine base horizontal speed based on state
            let baseSpeed = character.speed;
            
            // If we are in any flight state (Float, FlyUp, FlyDown), use the faster float speed
            if (character.isFloating || character.isFlyingUp || character.isFlyingDown) {
                baseSpeed = character.floatSpeed;
            }

            // Calculate current horizontal Speed (still uses multipliers)
            const currentSpeed = character.isTurbo ? baseSpeed * character.turboMultiplier : 
                                (character.isBoost ? baseSpeed * character.boostMultiplier : baseSpeed);

            // === VERTICAL SPEED LOGIC (SEPARATED FROM MULTIPLIERS) ===
            let currentFlyUpSpeed, currentFlyDownSpeed;

            if (character.isTurbo) {
                currentFlyUpSpeed = character.flyUpSpeedTurbo;
                currentFlyDownSpeed = character.flyDownSpeedTurbo;
            } else if (character.isBoost) {
                currentFlyUpSpeed = character.flyUpSpeedBoost;
                currentFlyDownSpeed = character.flyDownSpeedBoost;
            } else {
                currentFlyUpSpeed = character.flyUpSpeed;
                currentFlyDownSpeed = character.flyDownSpeed;
            }

            // === FIXED PARALLAX SPEED LOGIC ===
            // We decouple the parallax factor from the character's movement multiplier.
            // The character already moves faster (currentSpeed is higher), so the background moves faster naturally.
            // We use slightly higher parallax factors for Boost/Turbo for visual effect, but not the raw 3x/10x multipliers which caused the scrolling to glitch.
            let currentParallaxSpeed = background.parallaxSpeed; // Base is 15
            if (character.isTurbo) {
                currentParallaxSpeed = 30; 
            } else if (character.isBoost) {
                currentParallaxSpeed = 20;
            }
            
            // 1. Physics for Jumping
            if (character.isJumping) {
                character.velocityY += character.gravity;
                character.y += character.velocityY;
                
                // If we hit the ground while jumping (normal landing)
                if (character.y >= character.groundY) {
                    character.y = character.groundY;
                    character.isJumping = false;
                    character.velocityY = 0;
                }
            }
            
            // 2. Physics for Floating / Flying States
            if (character.isFloating) {
                // Just hover, W and S change the state to isFlyingUp / isFlyingDown
            } 
            else if (character.isFlyingUp) {
                // Move character upward
                character.y -= currentFlyUpSpeed;
                if (character.y < 0) character.y = 0;
            } 
            else if (character.isFlyingDown) {
                // Move character downward
                character.y += currentFlyDownSpeed;
                if (character.y > character.groundY) character.y = character.groundY;
            }
            
            // Handle W/S movement specifically for Boost/Turbo states (if not using anims)
            if ((character.isBoost || character.isTurbo) && !character.isFlyingUp && !character.isFlyingDown && (character.isFloating || character.isFlyingUp || character.isFlyingDown)) {
                 if (keys['w']) {
                     character.y -= currentFlyUpSpeed;
                     if (character.y < 0) character.y = 0;
                 }
                 if (keys['s']) {
                     character.y += currentFlyDownSpeed;
                     if (character.y > character.groundY) character.y = character.groundY;
                 }
            }

            // 3. Physics for Landing
            if (character.isLanding) {
                character.velocityY += character.gravity * 0.5;
                character.y += character.velocityY;
                
                if (character.y >= character.groundY) {
                    character.y = character.groundY;
                    character.velocityY = 0;
                    // Animation logic handles the boolean reset when frame finishes
                }
            }
            
            // 4. Character Movement Logic with Parallax
            character.isMoving = false;
            if (!character.isGlowing) {
                if (keys['a']) {
                    character.x -= currentSpeed;
                    character.direction = 'left';
                    character.isMoving = true;
                    background.x += currentSpeed * currentParallaxSpeed;
                    if (character.x < 0) character.x = 0;
                }
                
                if (keys['d']) {
                    character.x += currentSpeed;
                    character.direction = 'right';
                    character.isMoving = true;
                    background.x -= currentSpeed * currentParallaxSpeed;
                    if (character.x > canvas.width - character.width) {
                        character.x = canvas.width - character.width;
                    }
                }
            }
            
            // Update direction in boost/turbo mode
            if (character.isBoost || character.isTurbo) {
                if (keys['a']) character.direction = 'right';
                if (keys['d']) character.direction = 'left';
            }
            
            // 5. Character Animation Logic
            if (character.isLanding) {
                character.landFrameCounter++;
                if (character.landFrameCounter >= character.landFrameDelay) {
                    character.landFrameCounter = 0;
                    character.landFrameIndex++;
                    
                    if (character.landFrameIndex >= character.landFrameCount) {
                        character.isLanding = false;
                        character.landFrameIndex = 0;
                        character.velocityY = 0;
                    }
                }
            } else if (character.isTurbo) {
                character.turboFrameCounter++;
                if (character.turboFrameCounter >= character.turboFrameDelay) {
                    character.turboFrameCounter = 0;
                    character.turboFrameIndex = (character.turboFrameIndex + 1) % character.turboFrameCount;
                }
            } else if (character.isBoost) {
                character.boostFrameCounter++;
                if (character.boostFrameCounter >= character.boostFrameDelay) {
                    character.boostFrameCounter = 0;
                    character.boostFrameIndex = (character.boostFrameIndex + 1) % character.boostFrameCount;
                }
            } else if (character.isFlyingDown) {
                character.flyDownFrameCounter++;
                if (character.flyDownFrameCounter >= character.flyDownFrameDelay) {
                    character.flyDownFrameCounter = 0;
                    character.flyDownFrameIndex = (character.flyDownFrameIndex + 1) % character.flyDownFrameCount;
                }
            } else if (character.isFlyingUp) {
                character.flyUpFrameCounter++;
                if (character.flyUpFrameCounter >= character.flyUpFrameDelay) {
                    character.flyUpFrameCounter = 0;
                    character.flyUpFrameIndex = (character.flyUpFrameIndex + 1) % character.flyUpFrameCount;
                }
            } else if (character.isFloating) {
                character.floatFrameCounter++;
                if (character.floatFrameCounter >= character.floatFrameDelay) {
                    character.floatFrameCounter = 0;
                    character.floatFrameIndex = (character.floatFrameIndex + 1) % character.floatFrameCount;
                }
            } else if (character.isGlowing) {
                character.glowingFrameCounter++;
                if (character.glowingFrameCounter >= character.glowingFrameDelay) {
                    character.glowingFrameCounter = 0;
                    character.glowingFrameIndex++;
                    
                    if (character.glowingFrameIndex >= character.glowingFrameCount) {
                        character.isGlowing = false;
                        character.glowingFrameIndex = 0;
                    }
                }
            } else if (character.isJumping) {
                character.jumpFrameCounter++;
                if (character.jumpFrameCounter >= character.jumpFrameDelay) {
                    character.jumpFrameCounter = 0;
                    if (character.jumpFrameIndex < character.jumpFrameCount - 1) {
                        character.jumpFrameIndex++;
                    }
                }
            } else if (character.isMoving) {
                character.walkFrameCounter++;
                if (character.walkFrameCounter >= character.walkFrameDelay) {
                    character.walkFrameCounter = 0;
                    character.walkFrameIndex = (character.walkFrameIndex + 1) % character.walkFrameCount;
                }
            } else {
                character.idleFrameCounter++;
                if (character.idleFrameCounter >= character.idleFrameDelay) {
                    character.idleFrameCounter = 0;
                    character.idleFrameIndex = (character.idleFrameIndex + 1) % character.idleFrameCount;
                }
            }
            
            // 6. Background Animation Logic
            background.frameCounter++;
            if (background.frameCounter >= background.frameDelay) {
                background.frameCounter = 0;
                background.frameIndex = (background.frameIndex + 1) % background.frameCount;
            }
        }
        
        // Draw function
        function draw() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            // === LAYER 1: DRAW BACKGROUND WITH PARALLAX ===
            let currentBgImage = background.frames[background.frameIndex];
            
            if (currentBgImage && currentBgImage.complete && currentBgImage.naturalHeight !== 0) {
                let bgWidth = canvas.width;
                let bgHeight = canvas.height;
                let offsetX = background.x % bgWidth;
                
                ctx.drawImage(currentBgImage, offsetX - bgWidth, 0, bgWidth, bgHeight);
                ctx.drawImage(currentBgImage, offsetX, 0, bgWidth, bgHeight);
                ctx.drawImage(currentBgImage, offsetX + bgWidth, 0, bgWidth, bgHeight);
            }
            
            // === LAYER 2: DRAW CHARACTER ===
            let currentImage;
            let useDirection = true;
            
            if (character.isLanding) {
                currentImage = character.landFrames[character.landFrameIndex];
            } else if (character.isTurbo) {
                currentImage = character.turboFrames[character.turboFrameIndex];
            } else if (character.isBoost) {
                currentImage = character.boostFrames[character.boostFrameIndex];
            } else if (character.isFlyingDown) {
                currentImage = character.flyDownFrames[character.flyDownFrameIndex];
            } else if (character.isFlyingUp) {
                currentImage = character.flyUpFrames[character.flyUpFrameIndex];
            } else if (character.isFloating) {
                currentImage = character.floatFrames[character.floatFrameIndex];
            } else if (character.isGlowing) {
                currentImage = character.glowingFrames[character.glowingFrameIndex];
            } else if (character.isJumping) {
                currentImage = character.jumpFrames[character.jumpFrameIndex];
            } else if (character.isMoving) {
                currentImage = character.walkFrames[character.walkFrameIndex];
            } else {
                currentImage = character.idleFrames[character.idleFrameIndex];
            }
            
            if (currentImage && currentImage.complete && currentImage.naturalHeight !== 0) {
                if (character.direction === 'right') {
                    ctx.save();
                    ctx.translate(character.x + character.width / 2, 0); 
                    ctx.scale(-1, 1); 
                    ctx.translate(-(character.x + character.width / 2), 0);
                    ctx.drawImage(currentImage, character.x, character.y, character.width, character.height);
                    ctx.restore();
                } else {
                    ctx.drawImage(currentImage, character.x, character.y, character.width, character.height);
                }
            } else {
                // Fallback Character Box
                ctx.fillStyle = character.isLanding ? '#9C27B0' : 
                               (character.isTurbo ? '#00FF00' : 
                               (character.isBoost ? '#FFFF00' : 
                               (character.isFlyingDown ? '#FF6F00' : 
                               (character.isFlyingUp ? '#E91E63' : 
                               (character.isFloating ? '#00BFFF' : 
                               (character.isGlowing ? '#FFD700' : 
                               (character.isJumping ? '#FF5722' : '#4CAF50'))))))); 
                ctx.fillRect(character.x, character.y, character.width, character.height);
                ctx.fillStyle = '#fff';
                let eyeOffset = character.direction === 'right' ? 12 : 44;
                ctx.beginPath();
                ctx.arc(character.x + eyeOffset, character.y + 20, 8, 0, Math.PI * 2);
                ctx.fill();
            }
            
            ctx.restore();
            
            // UI Info
            ctx.fillStyle = '#888';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('A : Move Left', 20, 30);
            ctx.fillText('D : Move Right', 20, 50);
            ctx.fillText('SPACE (1x) : Jump', 20, 70);
            ctx.fillText('SPACE (2x - Mid Air) : Float', 20, 90);
            ctx.fillText('SPACE (3x - While Floating) : Land', 20, 110);
            ctx.fillText('SPACE (While Landing) : Float Again', 20, 130);
            ctx.fillText('G : Glowing', 20, 150);
            ctx.fillText('W : Fly Up (while floating)', 20, 170);
            ctx.fillText('S : Fly Down (while floating)', 20, 190);
            ctx.fillText('SHIFT + A/D : Boost (3x speed)', 20, 210);
            ctx.fillText('Hold SHIFT 3 sec : Turbo (10x speed)', 20, 230);
            ctx.fillText('Release SHIFT : Auto Land', 20, 250); // New UI Text
            ctx.fillText('Scroll / +/- : Zoom (' + zoom.toFixed(1) + 'x)', 20, 270);
            
            let stateText = character.isLanding ? "State: Landing" :
                           (character.isTurbo ? "State: TURBO!" :
                           (character.isBoost ? "State: BOOST!" :
                           (character.isFlyingDown ? "State: Flying Down" :
                           (character.isFlyingUp ? "State: Flying Up" : 
                           (character.isFloating ? "State: Floating" : 
                           (character.isGlowing ? "State: Glowing" : 
                           (character.isJumping ? "State: Jumping" : 
                           (character.isMoving ? "State: Walking" : "State: Idle"))))))));
            
            ctx.fillStyle = character.isLanding ? '#9C27B0' : 
                           (character.isTurbo ? '#00FF00' : 
                           (character.isBoost ? '#FFFF00' : 
                           (character.isFlyingDown ? '#FF6F00' : 
                           (character.isFlyingUp ? '#E91E63' : 
                           (character.isFloating ? '#00BFFF' : 
                           (character.isGlowing ? '#FFD700' : 
                           (character.isJumping ? '#FF5722' : 
                           (character.isMoving ? '#4CAF50' : '#FFC107'))))))));
            ctx.fillText(stateText, 20, 300);
            
            // Boost timer display
            if (character.isBoost) {
                const elapsedTime = Date.now() - character.boostStartTime;
                const remainingTime = ((character.boostDuration - elapsedTime) / 1000).toFixed(1);
                ctx.fillStyle = '#FFFF00';
                ctx.fillText(`Turbo in: ${remainingTime}s`, 20, 320);
            }
            
            // Frame Debug Info
            ctx.fillStyle = '#555';
            ctx.font = '12px Arial';
            ctx.fillText(`BG Frame: ${background.frameIndex + 1} / ${bgCount}`, 20, 350);
            ctx.fillText(`Position: X=${Math.round(character.x)}, Y=${Math.round(character.y)}`, 20, 370);
        }
        
        // Game Loop
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        gameLoop();
    </script>
</body>
</html>