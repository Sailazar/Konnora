<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Konno - Walking Character + Planting (Fixed Turbo Retain Direction)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background: #1a1a1a;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            border: 2px solid #333;
            background: #0a0a0a;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 1200;
        canvas.height = 800;
        
        let zoom = 1;
        const minZoom = 0.5;
        const maxZoom = 3;
        const zoomStep = 0.1;

        // ==========================================
        // === TURBO BOOST CONTROLS =================
        // ==========================================
        const turboBoostWidthScale = 4.6;
        const turboBoostHeightScale = 0.55;
        const turboBoostOffsetX = -303; 
        const turboBoostOffsetY = 13;  
        const turboBoostRotationAngle = -8; 

        const turboCharWidthScale = 1.0;
        const turboCharHeightScale = 1.0;
        const turboCharOffsetX = 0;      
        const turboCharOffsetY = -15;      
        const turboCharRotationAngle = 24; 
        // ==========================================
        
        let showUI = true;
        
        const plantCount = 214; 
        const treeCount = 122;
        const newTreeCount = 122;
        const turboBoostCount = 80;

        const character = {
            x: 400, y: 600, groundY: 600,
            width: 128, height: 128,
            speed: 0.3, floatSpeed: 0.9,
            boostMultiplier: 1, turboMultiplier: 5,
            direction: 'right', isMoving: false,
            isJumping: false, velocityY: 0, jumpPower: 10, gravity: 0.3,
            isGlowing: false, isFloating: false, isFlyingUp: false, isFlyingDown: false, isLanding: false,
            isBoost: false, isTurbo: false, boostStartTime: 0, boostDuration: 1500,
            flyUpSpeed: 2.1, flyDownSpeed: 2.1,
            flyUpSpeedBoost: 1.5, flyDownSpeedBoost: 1.5,
            flyUpSpeedTurbo: 3.0, flyDownSpeedTurbo: 3.0,
            walkFrameIndex: 0, walkFrameDelay: 0.3, walkFrameCounter: 0,
            idleFrameIndex: 0, idleFrameDelay: 3, idleFrameCounter: 0,
            jumpFrameIndex: 0, jumpFrameDelay: 3, jumpFrameCounter: 0,
            glowingFrameIndex: 0, glowingFrameDelay: 2, glowingFrameCounter: 0,
            floatFrameIndex: 0, floatFrameDelay: 0.7, floatFrameCounter: 0,
            flyUpFrameIndex: 0, flyUpFrameDelay: 0.5, flyUpFrameCounter: 0,
            flyDownFrameIndex: 0, flyDownFrameDelay: 0.5, flyDownFrameCounter: 0,
            landFrameIndex: 0, landFrameDelay: 0.5, landFrameCounter: 0,
            boostFrameIndex: 0, boostFrameDelay: 0.3, boostFrameCounter: 0,
            turboFrameIndex: 0, turboFrameDelay: 0.3, turboFrameCounter: 0,
            turboBoostFrameIndex: 0, turboBoostFrameDelay: 0.3, turboBoostFrameCounter: 0,
            walkFrames: [], idleFrames: [], jumpFrames: [], glowingFrames: [],
            floatFrames: [], flyUpFrames: [], flyDownFrames: [], landFrames: [],
            boostFrames: [], turboFrames: [], turboBoostFrames: []
        };

        let worldObjects = [];
        const plantFrames = [];
        const newTreeFrames = [];

        const background = {
            frames: [], frameIndex: 0, frameDelay: 3, frameCounter: 0,
            x: 0, y: 0, parallaxSpeed: 15, verticalParallaxSpeed: 8
        };
        
        const treeLayer = {
            frames: [], frameIndex: 0, frameDelay: 3, frameCounter: 0,
            x: 0, y: 0, parallaxSpeed: 25, verticalParallaxSpeed: 12
        };
        
        const newBackgroundLayer = {
            frames: [], frameIndex: 0, frameDelay: 3, frameCounter: 0,
            x: 0, y: 0, parallaxSpeed: 35, verticalParallaxSpeed: 16
        };
        
        const newBackground2Layer = {
            frames: [], frameIndex: 0, frameDelay: 3, frameCounter: 0,
            x: 0, y: 0, parallaxSpeed: 35, verticalParallaxSpeed: 16
        };
        
        function generateImageArray(prefix, count, folder) {
            let arr = [];
            for (let i = 1; i <= count; i++) {
                arr.push(`${folder}${prefix}_${i.toString().padStart(3, '0')}.png`);
            }
            return arr;
        }
        
        const walkCount = 126, idleCount = 126, jumpCount = 50, glowingCount = 50;
        const floatCount = 42, flyUpCount = 30, flyDownCount = 30, landCount = 110;
        const boostCount = 96, turboCount = 77, bgCount = 122, newBackgroundCount = 122;
        
        const srcs = {
            walk: generateImageArray('walk_right', walkCount, 'walk/'),
            idle: generateImageArray('Idle', idleCount, 'idle/'),
            jump: generateImageArray('jmp', jumpCount, 'jump/'),
            glowing: generateImageArray('glowing', glowingCount, 'glowing/'),
            float: generateImageArray('float', floatCount, 'float/'),
            flyUp: generateImageArray('higher', flyUpCount, 'higher/'),
            flyDown: generateImageArray('fly_down', flyDownCount, 'fly_down/'),
            land: generateImageArray('land', landCount, 'land/'),
            boost: generateImageArray('boost_speed', boostCount, 'boost_speed/'),
            turbo: generateImageArray('turbo', turboCount, 'turbo/'),
            turboBoost: generateImageArray('turbo_boost', turboBoostCount, 'turbo_boost/'),
            bg: generateImageArray('bg', bgCount, 'background/'),
            tree: generateImageArray('tree', treeCount, 'tree/'),
            newBackground: generateImageArray('newBackground', newBackgroundCount, 'newBackground/'),
            plant: generateImageArray('plant', plantCount, 'plant/'),
            newTree: generateImageArray('new_tree', newTreeCount, 'new_tree/')
        };
        
        function loadImages() {
            const loadSet = (srcArray, targetArray) => {
                srcArray.forEach(src => {
                    const img = new Image();
                    img.src = src;
                    targetArray.push(img);
                });
            };
            
            loadSet(srcs.walk, character.walkFrames);
            loadSet(srcs.idle, character.idleFrames);
            loadSet(srcs.jump, character.jumpFrames);
            loadSet(srcs.glowing, character.glowingFrames);
            loadSet(srcs.float, character.floatFrames);
            loadSet(srcs.flyUp, character.flyUpFrames);
            loadSet(srcs.flyDown, character.flyDownFrames);
            loadSet(srcs.land, character.landFrames);
            loadSet(srcs.boost, character.boostFrames);
            loadSet(srcs.turbo, character.turboFrames);
            loadSet(srcs.turboBoost, character.turboBoostFrames);
            loadSet(srcs.bg, background.frames);
            loadSet(srcs.tree, treeLayer.frames);
            loadSet(srcs.newBackground, newBackgroundLayer.frames);
            loadSet(srcs.newBackground, newBackground2Layer.frames);
            loadSet(srcs.plant, plantFrames);
            loadSet(srcs.newTree, newTreeFrames);
            
            character.walkFrameCount = walkCount;
            character.idleFrameCount = idleCount;
            character.jumpFrameCount = jumpCount;
            character.glowingFrameCount = glowingCount;
            character.floatFrameCount = floatCount;
            character.flyUpFrameCount = flyUpCount;
            character.flyDownFrameCount = flyDownCount;
            character.landFrameCount = landCount;
            character.boostFrameCount = boostCount;
            character.turboFrameCount = turboCount;
            character.turboBoostFrameCount = turboBoostCount;
            background.frameCount = bgCount;
            treeLayer.frameCount = treeCount;
            newBackgroundLayer.frameCount = newBackgroundCount;
            newBackground2Layer.frameCount = newBackgroundCount;
        }
        loadImages();
        
        const keys = {};
        
        window.addEventListener('keydown', (e) => {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key.toLowerCase() === 'p') {
                const depthLayer = Math.floor(Math.random() * 3);
                const scales = [0.4, 0.7, 1.0, 1.3, 1.6];
                const treeScale = scales[Math.floor(Math.random() * scales.length)];
                const yOffsets = [-150, -50, 0];
                const yOffset = yOffsets[depthLayer];
                const xVariance = (Math.random() - 0.5) * 100;
                
                worldObjects.push({
                    x: character.x + character.width / 2 + xVariance,
                    y: character.groundY + yOffset,
                    state: 'growing',
                    type: 'animated-tree',
                    frameIndex: 0,
                    frameCounter: 0,
                    frameDelay: 7,
                    plantScale: 1.0,
                    treeScale: treeScale,
                    depthLayer: depthLayer,
                    parallaxMultiplier: 1 - (depthLayer * 0.3)
                });
            }
            
            if (e.key.toLowerCase() === 'o') {
                const depthLayer = Math.floor(Math.random() * 3);
                const scales = [0.4, 0.7, 1.0, 1.3, 1.6];
                const treeScale = scales[Math.floor(Math.random() * scales.length)];
                const yOffsets = [-150, -50, 0];
                const yOffset = yOffsets[depthLayer];
                const xVariance = (Math.random() - 0.5) * 100;
                
                worldObjects.push({
                    x: character.x + character.width / 2 + xVariance,
                    y: character.groundY + yOffset,
                    state: 'growing-new-tree',
                    type: 'new-tree',
                    frameIndex: 0,
                    frameCounter: 0,
                    frameDelay: 7,
                    treeScale: treeScale,
                    depthLayer: depthLayer,
                    parallaxMultiplier: 1 - (depthLayer * 0.3)
                });
            }

            if (e.key === ' ' && !character.isGlowing) {
                if (character.isLanding) {
                    character.isLanding = false;
                    character.velocityY = 0;
                    character.isFloating = true;
                    character.floatFrameIndex = 0;
                } else if (!character.isJumping && !character.isFloating && !character.isFlyingUp && !character.isFlyingDown) {
                    character.isJumping = true;
                    character.velocityY = -character.jumpPower;
                    character.jumpFrameIndex = 0;
                } else if (character.isJumping) {
                    character.isJumping = false;
                    character.velocityY = 0;
                    character.isFloating = true;
                    character.floatFrameIndex = 0;
                } else if (character.isFloating || character.isFlyingUp || character.isFlyingDown) {
                    character.isFloating = false;
                    character.isFlyingUp = false;
                    character.isFlyingDown = false;
                    character.isLanding = true;
                    character.landFrameIndex = 0;
                }
            }
            
            if (e.key.toLowerCase() === 'g' && !character.isGlowing && !character.isJumping && !character.isFloating && !character.isLanding) {
                character.isGlowing = true;
                character.glowingFrameIndex = 0;
            }
            
            if (e.key.toLowerCase() === 'w' && character.isFloating && !character.isFlyingUp && !character.isFlyingDown) {
                character.isFlyingUp = true;
                character.isFloating = false;
                character.flyUpFrameIndex = 0;
            }
            
            if (e.key.toLowerCase() === 's' && character.isFloating && !character.isFlyingDown && !character.isFlyingUp) {
                character.isFlyingDown = true;
                character.isFloating = false;
                character.flyDownFrameIndex = 0;
            }
            
            if (e.key === 'Shift' && (character.isFloating || character.isFlyingUp || character.isFlyingDown) && !character.isBoost && !character.isTurbo && (keys['a'] || keys['d'])) {
                character.isBoost = true;
                character.boostStartTime = Date.now();
                character.boostFrameIndex = 0;
            }
            
            if (e.key === '+' || e.key === '=') zoom = Math.min(zoom + zoomStep, maxZoom);
            if (e.key === '-' || e.key === '_') zoom = Math.max(zoom - zoomStep, minZoom);
            if (e.key === '0') zoom = 1;
            
            if (e.key.toLowerCase() === 'h') {
                showUI = !showUI;
                console.log('UI toggle:', showUI);
            }
        });
        
        window.addEventListener('keyup', (e) => {
            keys[e.key.toLowerCase()] = false;
            
            if (e.key === 'Shift' && (character.isBoost || character.isTurbo)) {
                character.isBoost = false;
                character.isTurbo = false;
                character.isFloating = false;
                character.isFlyingUp = false;
                character.isFlyingDown = false;
                character.isLanding = true;
                character.landFrameIndex = 0;
                character.boostStartTime = 0;
            }
            
            if (e.key.toLowerCase() === 'w' && character.isFlyingUp) {
                character.isFlyingUp = false;
                character.isFloating = true;
                character.floatFrameIndex = 0;
            }
            
            if (e.key.toLowerCase() === 's' && character.isFlyingDown) {
                character.isFlyingDown = false;
                character.isFloating = true;
                character.floatFrameIndex = 0;
            }
        });
        
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            if (e.deltaY < 0) zoom = Math.min(zoom + zoomStep, maxZoom);
            else zoom = Math.max(zoom - zoomStep, minZoom);
        });
        
        function update() {
            if (character.isBoost && !character.isTurbo && keys['shift'] && (keys['a'] || keys['d'])) {
                const elapsed = Date.now() - character.boostStartTime;
                if (elapsed >= character.boostDuration) {
                    character.isBoost = false;
                    character.isTurbo = true;
                    character.turboFrameIndex = 0;
                    character.turboBoostFrameIndex = 0;
                }
            }
            
            let baseSpeed = (character.isFloating || character.isFlyingUp || character.isFlyingDown) ? character.floatSpeed : character.speed;
            const currentSpeed = character.isTurbo ? baseSpeed * character.turboMultiplier : (character.isBoost ? baseSpeed * character.boostMultiplier : baseSpeed);
            
            let flyUpSpeed = character.flyUpSpeed, flyDownSpeed = character.flyDownSpeed;
            if (character.isTurbo) {
                flyUpSpeed = character.flyUpSpeedTurbo;
                flyDownSpeed = character.flyDownSpeedTurbo;
            } else if (character.isBoost) {
                flyUpSpeed = character.flyUpSpeedBoost;
                flyDownSpeed = character.flyDownSpeedBoost;
            }
            
            let bgParallax = background.parallaxSpeed, treeParallax = treeLayer.parallaxSpeed, newBackgroundParallax = newBackgroundLayer.parallaxSpeed;
            let bgVerticalParallax = background.verticalParallaxSpeed, treeVerticalParallax = treeLayer.verticalParallaxSpeed, newBackgroundVerticalParallax = newBackgroundLayer.verticalParallaxSpeed;
            
            if (character.isTurbo) {
                bgParallax = 30; treeParallax = 40; newBackgroundParallax = 50;
                bgVerticalParallax = 15; treeVerticalParallax = 20; newBackgroundVerticalParallax = 25;
            } else if (character.isBoost) {
                bgParallax = 20; treeParallax = 30; newBackgroundParallax = 40;
                bgVerticalParallax = 12; treeVerticalParallax = 16; newBackgroundVerticalParallax = 20;
            }
            
            worldObjects.sort((a, b) => a.depthLayer - b.depthLayer);
            
            for (let i = 0; i < worldObjects.length; i++) {
                let obj = worldObjects[i];
                const parallaxFactor = obj.parallaxMultiplier || 1;
                if (keys['a']) obj.x += currentSpeed * treeParallax * parallaxFactor;
                if (keys['d']) obj.x -= currentSpeed * treeParallax * parallaxFactor;

                obj.frameCounter++;
                if (obj.frameCounter >= obj.frameDelay) {
                    obj.frameCounter = 0;

                    if (obj.state === 'growing') {
                        obj.frameIndex++;
                        if (obj.frameIndex >= plantCount) {
                            obj.state = 'grown';
                            obj.frameIndex = 0;
                            obj.frameDelay = 3;
                        }
                    } else if (obj.state === 'growing-new-tree') {
                        obj.frameIndex++;
                        if (obj.frameIndex >= newTreeCount) {
                            obj.state = 'grown-new-tree';
                            obj.frameIndex = 0;
                            obj.frameDelay = 3;
                        }
                    } else if (obj.state === 'grown') {
                        obj.frameIndex = (obj.frameIndex + 1) % treeCount;
                    } else if (obj.state === 'grown-new-tree') {
                        obj.frameIndex = (obj.frameIndex + 1) % newTreeCount;
                    }
                }
            }

            if (character.isJumping) {
                character.velocityY += character.gravity;
                character.y += character.velocityY;
                if (character.y >= character.groundY) {
                    character.y = character.groundY;
                    character.isJumping = false;
                    character.velocityY = 0;
                }
            }
            
            if (character.isFlyingUp) {
                character.y -= flyUpSpeed;
                if (character.y < 0) character.y = 0;
            } else if (character.isFlyingDown) {
                character.y += flyDownSpeed;
                if (character.y > character.groundY) character.y = character.groundY;
            }
            
            if ((character.isBoost || character.isTurbo) && !character.isFlyingUp && !character.isFlyingDown) {
                if (keys['w']) {
                    character.y -= flyUpSpeed;
                    if (character.y < 0) character.y = 0;
                }
                if (keys['s']) {
                    character.y += flyDownSpeed;
                    if (character.y > character.groundY) character.y = character.groundY;
                }
            }
            
            if (character.isLanding) {
                character.velocityY += character.gravity * 0.5;
                character.y += character.velocityY;
                if (character.y >= character.groundY) {
                    character.y = character.groundY;
                    character.velocityY = 0;
                }
            }
            
            character.isMoving = false;
            if (!character.isGlowing) {
                if (keys['a']) {
                    character.x -= currentSpeed;
                    character.direction = 'left';
                    character.isMoving = true;
                    background.x += currentSpeed * bgParallax;
                    treeLayer.x += currentSpeed * treeParallax;
                    if (character.x < 0) character.x = 0;
                }
                if (keys['d']) {
                    character.x += currentSpeed;
                    character.direction = 'right';
                    character.isMoving = true;
                    background.x -= currentSpeed * bgParallax;
                    treeLayer.x -= currentSpeed * treeParallax;
                    if (character.x > canvas.width - character.width) character.x = canvas.width - character.width;
                }
            }
            
            if (character.isLanding) {
                character.landFrameCounter++;
                if (character.landFrameCounter >= character.landFrameDelay) {
                    character.landFrameCounter = 0;
                    character.landFrameIndex++;
                    if (character.landFrameIndex >= character.landFrameCount) {
                        character.isLanding = false;
                        character.landFrameIndex = 0;
                        character.velocityY = 0;
                        character.idleFrameIndex = 0;
                    }
                }
            } else if (character.isTurbo) {
                character.turboFrameCounter++;
                if (character.turboFrameCounter >= character.turboFrameDelay) {
                    character.turboFrameCounter = 0;
                    character.turboFrameIndex = (character.turboFrameIndex + 1) % character.turboFrameCount;
                }
                character.turboBoostFrameCounter++;
                if (character.turboBoostFrameCounter >= character.turboBoostFrameDelay) {
                    character.turboBoostFrameCounter = 0;
                    character.turboBoostFrameIndex = (character.turboBoostFrameIndex + 1) % character.turboBoostFrameCount;
                }
            } else if (character.isBoost) {
                character.boostFrameCounter++;
                if (character.boostFrameCounter >= character.boostFrameDelay) {
                    character.boostFrameCounter = 0;
                    character.boostFrameIndex = (character.boostFrameIndex + 1) % character.boostFrameCount;
                }
            } else if (character.isFlyingDown) {
                character.flyDownFrameCounter++;
                if (character.flyDownFrameCounter >= character.flyDownFrameDelay) {
                    character.flyDownFrameCounter = 0;
                    character.flyDownFrameIndex = (character.flyDownFrameIndex + 1) % character.flyDownFrameCount;
                }
            } else if (character.isFlyingUp) {
                character.flyUpFrameCounter++;
                if (character.flyUpFrameCounter >= character.flyUpFrameDelay) {
                    character.flyUpFrameCounter = 0;
                    character.flyUpFrameIndex = (character.flyUpFrameIndex + 1) % character.flyUpFrameCount;
                }
            } else if (character.isFloating) {
                character.floatFrameCounter++;
                if (character.floatFrameCounter >= character.floatFrameDelay) {
                    character.floatFrameCounter = 0;
                    character.floatFrameIndex = (character.floatFrameIndex + 1) % character.floatFrameCount;
                }
            } else if (character.isGlowing) {
                character.glowingFrameCounter++;
                if (character.glowingFrameCounter >= character.glowingFrameDelay) {
                    character.glowingFrameCounter = 0;
                    character.glowingFrameIndex++;
                    if (character.glowingFrameIndex >= character.glowingFrameCount) {
                        character.isGlowing = false;
                        character.glowingFrameIndex = 0;
                        character.idleFrameIndex = 0;
                        character.idleFrameCounter = 0;
                    }
                }
            } else if (character.isJumping) {
                character.jumpFrameCounter++;
                if (character.jumpFrameCounter >= character.jumpFrameDelay) {
                    character.jumpFrameCounter = 0;
                    if (character.jumpFrameIndex < character.jumpFrameCount - 1) {
                        character.jumpFrameIndex++;
                    }
                }
            } else if (character.isMoving) {
                character.walkFrameCounter++;
                if (character.walkFrameCounter >= character.walkFrameDelay) {
                    character.walkFrameCounter = 0;
                    character.walkFrameIndex = (character.walkFrameIndex + 1) % character.walkFrameCount;
                }
            } else {
                character.idleFrameCounter++;
                if (character.idleFrameCounter >= character.idleFrameDelay) {
                    character.idleFrameCounter = 0;
                    character.idleFrameIndex = (character.idleFrameIndex + 1) % character.idleFrameCount;
                }
            }
            
            background.frameCounter++;
            if (background.frameCounter >= background.frameDelay) {
                background.frameCounter = 0;
                background.frameIndex = (background.frameIndex + 1) % background.frameCount;
            }
            
            treeLayer.frameCounter++;
            if (treeLayer.frameCounter >= treeLayer.frameDelay) {
                treeLayer.frameCounter = 0;
                treeLayer.frameIndex = (treeLayer.frameIndex + 1) % treeLayer.frameCount;
            }
            
            newBackgroundLayer.frameCounter++;
            if (newBackgroundLayer.frameCounter >= newBackgroundLayer.frameDelay) {
                newBackgroundLayer.frameCounter = 0;
                newBackgroundLayer.frameIndex = (newBackgroundLayer.frameIndex + 1) % newBackgroundLayer.frameCount;
            }
            
            newBackground2Layer.frameCounter++;
            if (newBackground2Layer.frameCounter >= newBackground2Layer.frameDelay) {
                newBackground2Layer.frameCounter = 0;
                newBackground2Layer.frameIndex = (newBackground2Layer.frameIndex + 1) % newBackground2Layer.frameCount;
            }
        }
        
        function draw() {
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-canvas.width / 2, -canvas.height / 2);
            
            const drawParallax = (layer, offsetName, scale = 1) => {
                const img = layer.frames[layer.frameIndex];
                if (img && img.complete && img.naturalHeight !== 0) {
                    const w = canvas.width * scale, h = canvas.height * scale;
                    const offsetX = layer.x % w;
                    const offsetY = layer.y % h;
                    for (let dy = -2; dy <= 2; dy++) {
                        for (let dx = -2; dx <= 2; dx++) {
                            ctx.drawImage(img, offsetX + dx * w, offsetY + dy * h, w, h);
                        }
                    }
                }
            };

            const drawStaticLeft = (layer, scale = 1) => {
                const img = layer.frames[layer.frameIndex];
                if (img && img.complete && img.naturalHeight !== 0) {
                    const w = canvas.width * scale, h = canvas.height * scale;
                    ctx.drawImage(img, 0, 0, w, h);
                }
            };
            
            drawParallax(background, 'x', 1);
            
            worldObjects.forEach(obj => {
                if (obj.x > -300 && obj.x < canvas.width + 300) {
                    let img;
                    let scale;
                    
                    if (obj.state === 'growing') {
                        img = plantFrames[obj.frameIndex];
                        scale = obj.plantScale || 1.0;
                    } else if (obj.state === 'growing-new-tree') {
                        img = newTreeFrames[obj.frameIndex];
                        scale = obj.treeScale || 1.0;
                    } else if (obj.state === 'grown-new-tree') {
                        img = newTreeFrames[obj.frameIndex];
                        scale = obj.treeScale || 1.0;
                    } else {
                        img = treeLayer.frames[obj.frameIndex];
                        scale = obj.treeScale || 1.0;
                    }
                    
                    if (img && img.complete && img.naturalHeight !== 0) {
                        const scaledWidth = img.width * scale;
                        const scaledHeight = img.height * scale;
                        const drawX = obj.x - (scaledWidth / 2);
                        const drawY = obj.y - scaledHeight;
                        
                        if (obj.state === 'grown' || obj.state === 'grown-new-tree') {
                            const alpha = 0.5 + (obj.depthLayer * 0.25);
                            ctx.globalAlpha = alpha;
                    }
                    
                    ctx.drawImage(img, drawX, drawY, scaledWidth, scaledHeight);
                    ctx.globalAlpha = 1.0;
                } else {
                    if (obj.state === 'growing' || obj.state === 'growing-new-tree') {
                        ctx.fillStyle = `rgba(100, 255, 100, ${obj.frameIndex / plantCount})`;
                        const size = (20 + (obj.frameIndex * 2)) * scale;
                        ctx.fillRect(obj.x - size/2, obj.y - size, size, size);
                    } else {
                        ctx.fillStyle = '#228B22';
                        ctx.fillRect(obj.x - 30 * scale, obj.y - 80 * scale, 60 * scale, 80 * scale);
                    }
                }
            }
        });
         
        // ==========================================
        // === TURBO EFFECT & BODY DRAWING =========
        // ==========================================
        if (character.isTurbo) {
            const pivotX = character.x + character.width / 2 + turboCharOffsetX;
            const pivotY = character.y + character.height / 2 + turboCharOffsetY;
            
            // FIX: Use character.direction instead of keys['d']
            // This ensures the direction stays correct even if you stop pressing D
            const facingRight = character.direction === 'right';
            const scaleX = facingRight ? 1 : -1;

            ctx.save();
            ctx.translate(pivotX, pivotY);
            ctx.scale(scaleX, 1);

            const tailImg = character.turboBoostFrames[character.turboBoostFrameIndex];
            if (tailImg && tailImg.complete && tailImg.naturalHeight !== 0) {
                const tailW = character.width * turboBoostWidthScale;
                const tailH = character.height * turboBoostHeightScale;
                
                ctx.save();
                ctx.rotate(turboBoostRotationAngle * (Math.PI / 180));
                ctx.drawImage(tailImg, 
                    -tailW/2 + turboBoostOffsetX, 
                    -tailH/2 + turboBoostOffsetY, 
                    tailW, tailH
                );
                ctx.restore();
            }

            const bodyImg = character.turboFrames[character.turboFrameIndex];
            if (bodyImg && bodyImg.complete && bodyImg.naturalHeight !== 0) {
                const bodyW = character.width * turboCharWidthScale;
                const bodyH = character.height * turboCharHeightScale;
                ctx.save();
                ctx.rotate(turboCharRotationAngle * (Math.PI / 180));
                ctx.drawImage(bodyImg, -bodyW/2, -bodyH/2, bodyW, bodyH);
                ctx.restore();
            } else {
                ctx.fillStyle = '#00FF00';
                ctx.fillRect(-character.width/2, -character.height/2, character.width, character.height);
            }

            ctx.restore();
        }
        // ==========================================
        // === END TURBO DRAWING ===================
        // ==========================================

        let img;
        if (character.isLanding) img = character.landFrames[character.landFrameIndex];
        else if (character.isTurbo) { /* Handled above */ }
        else if (character.isBoost) img = character.boostFrames[character.boostFrameIndex];
        else if (character.isFlyingDown) img = character.flyDownFrames[character.flyDownFrameIndex];
        else if (character.isFlyingUp) img = character.flyUpFrames[character.flyUpFrameIndex];
        else if (character.isFloating) img = character.floatFrames[character.floatFrameIndex];
        else if (character.isGlowing) img = character.glowingFrames[character.glowingFrameIndex];
        else if (character.isJumping) img = character.jumpFrames[character.jumpFrameIndex];
        else if (character.isMoving) img = character.walkFrames[character.walkFrameIndex];
        else img = character.idleFrames[character.idleFrameIndex];
        
        // ==========================================
        // === STANDARD CHARACTER DRAWING =========
        // ==========================================
        if (!character.isTurbo && img) {
            if (img.complete && img.naturalHeight !== 0) {
                const w = character.width;
                const h = character.height;
                const x = character.x;
                const y = character.y;

                ctx.save();
                // Move to center of character
                ctx.translate(x + w / 2, y + h / 2);

                // LOGIC FIX:
                // 1. Boost sprites face Right (like Turbo).
                // 2. Normal sprites (Walk, Idle, Jump, Land, Float, Fly) face Left.
                
                if (character.isBoost) {
                    // Boost sprites face Right. Flip ONLY if moving Left.
                    if (character.direction === 'left') {
                        ctx.scale(-1, 1);
                    }
                } else {
                    // Normal sprites face Left. Flip ONLY if moving Right.
                    if (character.direction === 'right') {
                        ctx.scale(-1, 1);
                    }
                }

                // Draw image centered on origin
                ctx.drawImage(img, -w / 2, -h / 2, w, h);

                ctx.restore();
            } else {
                // Fallback rectangle
                const colors = ['#4CAF50', '#4CAF50', '#FF5722', '#FFD700', '#00BFFF', '#E91E63', '#FF6F00', '#FFFF00', '#00FF00', '#9C27B0'];
                const states = [0, character.isMoving, character.isJumping, character.isGlowing, character.isFloating, character.isFlyingUp, character.isFlyingDown, character.isBoost, character.isTurbo, character.isLanding];
                ctx.fillStyle = colors[states.indexOf(true)];
                ctx.fillRect(character.x, character.y, character.width, character.height);
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                const eyeX = character.direction === 'left' ? character.x + 38 : character.x + 90;
                ctx.arc(eyeX, character.y + 20, 8, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        drawParallax(treeLayer, 'x', 1.5);
        drawStaticLeft(newBackgroundLayer, 1);
        drawStaticLeft(newBackground2Layer, 1);
        ctx.restore();
        
        if (showUI) {
            ctx.fillStyle = '#fff';
            ctx.font = '16px Arial';
            ctx.textAlign = 'left';
            const controls = [
                'A : Move Left', 'D : Move Right', 'SPACE (1x) : Jump',
                'SPACE (2x - Mid Air) : Float', 'SPACE (3x - While Floating) : Land',
                'SPACE (While Landing) : Float Again', 'G : Glowing',
                'W : Fly Up (while floating)', 'S : Fly Down (while floating)',
                'P : Plant Animated Tree (loops animation)', 
                'O : Plant New Tree (new_tree folder, loops animation)',
                'SHIFT + A/D : Boost (3x speed)', 'Hold SHIFT 3 sec : Turbo (10x speed + effect)',
                'Release SHIFT : Auto Land', 'Scroll / +/- : Zoom (' + zoom.toFixed(1) + 'x)',
                'H : Hide/Show Controls'
            ];
            controls.forEach((text, i) => ctx.fillText(text, 20, 30 + i * 20));
            
            const stateNames = ['Idle', 'Walking', 'Jumping', 'Glowing', 'Floating', 'Flying Up', 'Flying Down', 'BOOST!', 'TURBO!', 'Landing'];
            const stateColors = ['#FFC107', '#4CAF50', '#FF5722', '#FFD700', '#00BFFF', '#E91E63', '#FF6F00', '#FFFF00', '#00FF00', '#9C27B0'];
            const stateIdx = [0, character.isMoving, character.isJumping, character.isGlowing, character.isFloating, character.isFlyingUp, character.isFlyingDown, character.isBoost, character.isTurbo, character.isLanding].lastIndexOf(true);
            ctx.fillStyle = stateColors[stateIdx];
            ctx.fillText('State: ' + stateNames[stateIdx], 20, 330);
            
            if (character.isBoost) {
                const remaining = ((character.boostDuration - (Date.now() - character.boostStartTime)) / 1000).toFixed(1);
                ctx.fillStyle = '#FFFF00';
                ctx.fillText(`Turbo in: ${remaining}s`, 20, 350);
            }

            ctx.fillStyle = '#888';
            ctx.fillText(`World Objects (Trees): ${worldObjects.length}`, 20, 370);
            
            ctx.fillStyle = '#555';
            ctx.font = '12px Arial';
            ctx.fillText(`BG: ${background.frameIndex + 1}/${bgCount} | Tree: ${treeLayer.frameIndex + 1}/${treeCount}`, 20, 390);
            ctx.fillText(`Position: X=${Math.round(character.x)}, Y=${Math.round(character.y)}`, 20, 410);
        } else {
            ctx.fillStyle = '#888';
            ctx.font = '14px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Press H to show controls', 20, 30);
        }
    }
        
    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }
    gameLoop();
    </script>
</body>
</html>